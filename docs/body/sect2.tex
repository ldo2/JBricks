\ProvidesFile{sect2.tex}[2003/09/19 Проектный анализ]

\section{Проектный анализ}
В этом разделе будет описано множество объектов, образующих в совокупности
игру. Мы будем использовать UML 
(Unified Modeling Language~--- унифицированный язык моделирования)
в качестве языка описания и Java в качестве языка программирования.
Базовые понятия UML, необходимые для изложения проекта, представлены ниже.
Знание основ объектно-ориентированного программирования и языка Java
предполагаются.

\subsection{Диаграммы случаев использования}
При разработке объектно-ориентированного программного обеспечения
весьма эффективным является формулирование требований к отдельным
объектам с помощью {\em случаев использования}.

{\bf Случай использования (use case)} описывает, как действующий
субъект взаимодействует с системой.
Действующие субъекты (актёры) исполняют различные
роли, в которых пользователи выступают по отношению к системе. В нашем проекте 
явно присутствует только один субъект (игрок), но можно предположить наличие
ещё одного действующего субъекта (администратора), который при установкe игры
на различные компьютеры будет изменять её параметры: 
размер игрового поля, количество и скорость шайб и т.~д.
Основные случаи использования проекта перечислены в таблице~\ref{tbl:cases}.

\begin{table}[ht]
\caption{Основные случаи использования}\label{tbl:cases}
\begin{center}
\begin{tabular}{|l|c|}
\hline
Наименование & Описание \\
\hline
\hline
\multicolumn{2}{|r|}{Start (Начало)  Игрок начинает сеанс игры }\\
\hline
Pause (Приостановка)  & Игрок делает перерыв в игре \\
\hline
Resume (Возобновление) & Игрок возобновляет сеанс игры \\
\hline
Stop (Конец) & Игрок завершает сеанс игры \\
\hline
\end{tabular} 
\end{center}
\end{table}

Случаи использования упорядочены в иерархию с помощью двух отношений:
{\bf uses} (использует) и {\bf extends} (расширяет). Можно уточнить
некоторые из случаев использования и развернуть их в наборы более специфичных 
случаев (рис.~\ref{usecases}).
Подобная структура позволяет упростить поиск 
нужного случая. Нужно отметить, что случаи использования являются не
программами, а  требованиями, которым должно соответствовать
программное обеспечение.


\if{
\begin{figure}[ht]
\begin{center}
%\includegraphics[scale=0.5]{images/usecases.eps}
\includegraphics[scale=0.5]{mand.eps}
\end{center}
\caption{Случаи использования игры <<Кирпичики>>}\label{usecases}
\end{figure}
}\fi


В контексте конкретного случая использования можно определить один 
или большее число {\em сценариев}. Например, случай использования <<Двигать
лопатку>> порождает следующие сценарии перемещения лопатки влево перед
её столкновением с шайбой, движущейся слева направо:
\begin{itemize}
\item перемещение, обеспечивающее столкновение в средней трети лопатки;
\item перемещение, обеспечивающее столкновение в дальней трети лопатки;
\item перемещение, обеспечивающее столкновение в ближней трети лопатки.
\end{itemize}

Сценарии применяются к объектам, в которых значения атрибутов конкретизированы.
Это отличает их от случаев использования, которые ориентированы на работу
с объектами без конкретных значений атрибутов. 
Случаи использования обычно формулируют на естественном языке, а затем
представляют в графической форме в виде диаграммы (рис.~\ref{usecases}). 

\subsection{Объекты и классы}
Описав требования при помощи диаграмм использования, приступим
к созданию модели классов игры, часто называемой {\em диаграммой классов}.
Сначала напомним базовые концепции
объектно-ориентированного программирования
и способы графического представления различных компонент объектного
мира при помощи языка UML. 
 
{\bf Объект} --- операционная категория, которая содержит
значения данных (атрибуты) и программный код, манипулирующий 
этими данными~(методы). Объект является основой
объектно-ориентированной программы, которую можно
рассматривать как совокупность объектов. В процессе выполнения
программы объекты создаются, взаимодействуют друг с другом,
изменяются и, наконец, уничтожаются.

В игре <<Кирпичики>> имеется целый ряд различных 
объектов: лопатка, шайбы, кирпичи, игровое поле и его границы
(стены, потолок, пол),--- со своими наборами атрибутов и методов.
Объект <<шайба>>, например, инкапсулирует такие атрибуты, как
размер, форма, положение на игровом поле и текущая скорость,
а среди его методов содержатся операции перемещения шайбы и её
удаления с игрового поля в случае падения шайбы на пол.

{\bf Метод} --- запрос на выполнение определённой операции конкретным объектом.
Он состоит из имени и параметров, используемых при выполнении операции.

{\bf Класс} --- описание множества объектов, которые разделяют общие
свойства, отношения и смысл. Многие программисты рассматривают класс как 
шаблон для построения объекта. Объекты являются базовыми элементами при
выполнении объектно-ориентированных программ, а классы --- базовыми элементами
при определении таких программ.

Любой объект, используемый в объектно-ориентированной программе, должен быть
экземпляром некоторого класса, который предварительно необходимо
спроектировать и реализовать.
Различают внешнее представление класса (интерфейс) и его реализацию.
Интерфейс объявляет возможности класса, но скрывает его структуру и
поведение.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.7]{images/PuckSupply.eps}
\end{center}
\caption{Диаграмма класса PuckSupply} \label{ps}
\end{figure}

Интерфейс, как правило, состоит из объявлений всех операций (методов),
применимых к экземплярам класса (объектам), и может быть 
разделён на три части:
\begin{itemize}
\item публичную (public), объявления которой доступны всем клиентам
(в UML знак <<$+$>>);
\item защищённую (protected), используемую лишь объектами данного класса
и выведенными из него (знак <<\#>>);
\item закрытую (private), доступную только самому 
классу (знак <<$-$>>).
\end{itemize}

Интерфейс класса {\tt PuckSupply} (склад шайб) изображён на рис.~\ref{ps}.
Этот класс представляет собой набор шайб, выдаваемых игроку в начале игры.
Когда шайба выходит из игры (падает на пол), программа
заменяет её другой, если их запас ещё не исчерпан.

А вот как может выглядеть реализация данного класса на языке Java.
\begin{small}
\verbatiminput{examples/PuckSupply.java}
\end{small}

\subsection{Отношения между классами}

Классы, используемые в том или ином проекте, не существуют изолированно
друг от друга. Между ними всегда имеются определённые отношения,
среди которых можно выделить 
{\em ассоциацию}, {\em наследование}, {\em агрегацию} и {\em зависимость}.

{\bf Ассоциации} обеспечивают взаимодействие объектов, принадлежащих разным
классам. Они являются <<клеем>>, соединяющим воедино все элементы программной
системы.
Примером ассоциации является связь класса {\tt PuckSupply} и {\tt Puck}
(шайба). {\tt PuckSupply} играет роль хранилища, в котором находятся шайбы. 
Данная ассоциация (рис.~\ref{assoc}) предполагает двустороннюю связь.
Для экземпляра класса, реализующего склад шайб, выделяются все хранимые шайбы,
а для шайбы выделяется экземпляр хранилища. 

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.7]{images/assoc.eps}
\end{center}
\caption{Пример ассоциации}\label{assoc}
\end{figure}

При графическом изображении ассоциации каждый из двух концов линии, её 
изображающей, иногда снабжают некоторой меткой, называемой {\em именем роли}. 
Ещё одним параметром, характеризующим классы, связанные ассоциацией, 
является {\em кратность}, которая указывает количество объектов, участвующих
в данном отношении. В нашем проекте количество шайб в хранилище может
принимать значения от нуля до трёх, что и показано на рисунке. Символ <<$*$>>,
использованный в качестве кратности, означает диапазон от нуля до
бесконечности. Например, на игровом поле может находиться произвольное
количество кирпичей.

Вот несколько других примеров ассоциаций с различными кратностями:
\begin{itemize}
\item у европейской жены один муж, у которого одна жена (отношение <<один к
одному>>);
\item у восточной жены один муж, у которого может быть произвольное
число жён (отношение <<один ко многим>>);
\item человек может посещать сколько угодно зданий, в каждом из которых 
может находиться произвольное число людей (отношение <<многие ко многим>>).
\end{itemize}

{\bf Наследование} --- это отношение, при котором один класс разделяет
структуру и поведение другого класса (простое наследование)
или сразу нескольких классов (множественное наследование). Новый класс
называется {\em выведенным}, {\em производным\/} или {\em подклассом}.
<<Родительский>> класс принято называть {\em базовым\/} или {\em суперклассом}.
Совокупность классов, каждый элемент которой непосредственно или косвенно
наследует свойства какого-то одного конкретного класса ({\em корневого}),
называется {\em иерархией наследования}.

Построим иерархию наследования нашего проекта,
корнем которой будет класс {\tt Sprite}. Спрайт --- это абстракция,
представляющая любой объект, который может появиться
на игровом поле (слово <<спрайт>> имеет исторические корни и 
является <<стандартом>> для аркадных игр). Его атрибутами являются:
изображение (визуальный образ), положение на игровом
поле и размеры (ширина и высота).  

{\tt MovableSprite} (подвижный спрайт) --- это спрайт,
способный изменять свое местоположение. С таким спрайтом ассоциирована
скорость движения в текущий момент времени.
Скорость ({\tt Velocity}) представлена направлением движения и расстоянием, 
преодолеваемым за единицу времени.
В нашем проекте 
подвижными спрайтами являются шайба {\tt(Puck)} и лопатка {\tt (Puddle)}. 

{\tt StationarySprite} (неподвижный спрайт) не меняет своего положения
на игровом поле. Единственным примером такого спрайта в проекте 
является кирпич ({\tt Brick}). При изображении иерархии классов 
принято отношение наследования указывать стрелкой
с незакрашенным наконечником, направленной от производного класса к базовому
(рис.~\ref{sprites}).

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.7]{images/Sprites.eps}
\end{center}
\caption{Иерархия объектов игрового поля}\label{sprites}
\end{figure}


{\bf Агрегация} --- описывает отношение <<является частью>>.
Например, можно сказать, что двигатель и колёса являются частью автомобиля.
Кроме агрегации в языке UML определено более сильное понятие, называемое
{\em композицией}. При композиции объект-часть может принадлежать
только одному целому и, как правило, жизненный цикл части совпадает с
жизненным циклом целого, т.~е. части живут и умирают вместе с целым.
Агрегацию изображают в виде стрелки с наконечником в форме ромба.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.7]{images/collide.eps}
\end{center}
\caption{Отношение зависимости}\label{collide}
\end{figure}

{\bf Зависимость} --- это отношение, которое показывает, что изменения в одном
классе могут повлиять на другой. Графически зависимость изображается пунктирной
стрелкой, идущей от зависимого класса к тому, от которого он зависит.
Наиболее часто зависимости показывают, что один класс использует другой класс 
в качестве аргумента какого-то из своих методов. Например, в рамках нашего
проекта подвижный спрайт может столкнуться с любым другим спрайтом.
Данная зависимость представлена в виде метода {\tt collideInto} 
класса {\tt MovableSprite}, аргументом которого может быть любой спрайт, 
находящийся на игровом поле (рис.~\ref{collide}).

Диаграмма классов, изображённая на рис.~\ref{classes}, представляет статическую
картину проекта, учитывающую связи между различными классами. Функции
многих из них уже были описаны, и теперь необходимо пояснить назначение
оставшихся.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=1.0\textwidth]{images/Bricks.eps}
\end{center}
\caption{Диаграмма классов}\label{classes}
\end{figure}

{\tt Match} --- описывает сеанс игры, непосредственно связанный с игроком.
Сеанс игры может быть начат {\tt (start)}, приостановлен {\tt (stop)} и
возобновлён {\tt (resume)}. Игрок может проиграть {\tt (loose)} или выиграть
{\tt (win)}. С сеансом ассоциированы игровое поле, кирпичи и шайбы.

Рассмотрим более подробно назначение класса {\tt PlayField} (игровое поле). 
На нём изображaются все игровые объекты, которые хранятся в специально
созданном для этого классе --- векторе спрайтов, отвечающем за обновление
{\tt (update)} и перерисовку {\tt (draw)}.
Под обновлением подразумевается любое изменения состояния спрайта,
например, перемещение лопатки или разбивание кирпича шайбой,
влекущее за собой его удаление с игрового поля. 

Классы {\tt PuckSupply} и {\tt BrickPile} --- контейнеры. Первый содержит 
шайбы, а второй хранит кирпичи и задаёт 
положение каждого из них на игровом поле.
С помощью {\tt PuckSupply} можно узнать о проигрыше
игрока (все шайбы закончились), а {\tt BrickPile} 
предоставляет информацию о выигрыше (все кирпичи разбиты).

Теперь расскажем более подробно о реализации класса {\tt Sprite}.
Положение и размеры спрайта задаются атрибутом {\tt \_pos} типа {\tt Rectangle}
(прямоугольник). Пересечение двух спрайтов {\tt testCollision} находится как
пересечение двух принадлежащих им
прямоугольников-позиций\footnote{Такой способ называется простой прямоугольной
коллизией. Существуют и более совершенные методы, основанные на данных
изображения спрайта.}. Метод {\tt isDead} отражает состояние спрайта:
<<жив>> или <<мёртв>>. <<Мёртвый>> спрайт удаляется с игрового поля.

\begin{small}
\verbatiminput{examples/Sprite.java}
\end{small} 

{\tt MovableSprite} расширяет базовый класс {\tt Sprite}, добавляя возможность
движения при помощи метода {\tt move}, который контролирует также столкновения
как с границами игрового поля, так и с другими спрайтами. В случаях
столкновения с другими спрайтами вызывается метод {\tt collideInto}, а 
столкновения с границами игрового поля обрабатываются отдельно. 

\begin{small}
\verbatiminput{examples/Puck.java}
\end{small}

Класс {\tt Velocity} отвечает за движение подвижного спрайта по полю;
его компонентами являются абсолютная величина скорости и направление
движения. Величина скорости задаётся в некоторых условных единицах,
а направление --- в
градусах (при этом 0 означает движение на восток, 90 ---  на юг и т.~д., см.
рис.~\ref{velocity}).

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.9]{images/velocity.eps}
\end{center}
\caption{Задание скорости}\label{velocity}
\end{figure}
 
Атрибут <<скорость>> разделён на две составляющих: {\tt dx} и  {\tt dy} ---
проекции скорости на горизонтальную и вертикальную оси соответственно.
В то время как величина скорости всегда неотрицательна, её составляющие
могут принимать произвольные значения. 

\begin{small}
\verbatiminput{examples/Velocity.java}
\end{small}

Класс {\tt Velocity} содержит также методы  {\tt setDirection}, {\tt reverseX},
{\tt reverseY} и {\tt reverse}, позволяющие повысить эффективность
программы, устраняя необходимость создания новых экземпляров класса всякий раз,
когда изменяется направление движения. 

\endinput
